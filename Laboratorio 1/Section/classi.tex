\section{Classi}
\label{Classi}

Per implementare gli algoritmi sono state create 4 classi di oggetti, una classe di Utility e un Main.

\subsection{Arco}
\label{Arco}

L'oggetto \textit{Arco} contiene le infomazioni relative ad un arco:

\begin{itemize}
    \item \textbf{nodo1}: nodo iniziale;
    \item \textbf{nodo2}: nodo finale;
    \item \textbf{peso}: peso dell'arco;
    \item \hypertarget{getarco}{\textbf{\textsc{getArco()}}}: funzione che restituisce una lista [nodo1, nodo2, peso];
    \item \hypertarget{getarcoinverso}{\textbf{\textsc{getArcoInverso()}}}: funzione che, chiamata su un arco \emph{(u,v)} , ne restituisce l'inverso \emph{(v,u)}.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Grafo}
\label{Grafo}

L'oggetto \textit{Grafo} contiene le informazioni relative ad un grafo:

\begin{itemize}
    \item \textbf{n\_nodi}: campo dati che indica il numero dei nodi;
    \item \textbf{n\_archi}: campo dati che indica il numero degli archi;
    \item \textbf{lista\_nodi}: campo dati che contiene un insieme set() di nodi; 
    \item \textbf{lista\_archi}: campo dati che contiene la lista di oggetti arco;
    \item \textbf{id2Node}: dizionario avente come campo key l'identificatore di un nodo (intero) e come valore l'oggetto nodo corrispondente a quell'identificativo;
    \item \textbf{lista\_adiacenza}: dizionario avente come campo key l'intero corrispondente ad un nodo,  e come valore la lista di archi adiacenti al nodo;
    \item \textbf{lista\_adiacenza\_nodi}: dizionario avente come campo key l'intero corrispondente ad un nodo,  e come valore la lista di oggetti nodi adiacenti al nodo;
    \item \textbf{totPeso}: campo dati che indica il peso totale degli archi del grafo, calcolato da uno degli algoritmi presentati;
    \item \hypertarget{aggiungiarco}{\textbf{\textsc{aggiungiArco(arco)}}}: metodo che dato in input un arco lo aggiunge agli archi del grafo;
    \item \hypertarget{getnodo}{\textbf{\textsc{getNodo(id\_nodo)}}}: metodo che dato in input l'id di un nodo restituisce l'oggetto del nodo corrispondente;
    \item \hypertarget{getlistanodi}{\textbf{\textsc{getListaNodi()}}}: metodo che restituisce la lista di  oggetti nodi;
    \item \hypertarget{getgrafoprim}{\textbf{\textsc{getGrafoPrim()}}}: metodo che, utilizzando le relazioni padre-figlio risultanti dall'algoritmo Prim, restituisce un nuovo grafo basato su tali relazioni (utile per i test).
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Nodo}
\label{Nodo}

L'oggetto \textit{Nodo} contiene le informazioni relative ad un nodo:

\begin{itemize}
    \item \textbf{nodo}: Intero identificativo del nodo;
    \item \textbf{padre}: Intero che identifica il padre v di un nodo u nell'albero di copertura minimo;
    \item \textbf{size}: intero utilizzato per la struttura union-find;
    \item \textbf{key}: Campo utilizzato per costruire il min-heap, inizializzato con il peso dell'arco adiacente al nodo. Ad esempio il campo key del nodo \emph{u} sarà inizializzato con il valore \emph{w(u,v)};
    \item \hypertarget{inh}{\textbf{in\_h}}: Intero per verificare se un nodo è stato estratto dallo heap o meno;
    \item \textbf{heapIndex}: indice utilizzato per tenere traccia della posizione di ogni nodo all'interno dellp heap.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Utility}
\label{Utility}

La classe \textit{Utility} contiene le funzioni di servizio per implementare i tre algoritmi. In questa classe sono state aggiunte anche le funzioni necessarie per costruire la struttura dati UnionFind e alcune funzioni utili per le prove di correttezza dei risultati.

\begin{itemize}
    
    \item \hypertarget{inizializzagrafo}{\textbf{\textsc{inizializzaGrafo(n\_g, g)}}}: metodo che prende in input un grafo \textsc{g} ed inizializza il grafo \textsc{n\_g} con gli stessi nodi;
    
    \item \hypertarget{merge}{\textbf{\textbf{\textsc{merge(array, p, q, r)}}}}: metodo che implementa l'algoritmo merge modificato per confrontare i pesi degli archi. Data una lista archi, p, q, r sono indici dell'array, tali che \texttt{p <= q < r}. Gli indici dividono l'array in sottosequenze: \texttt{A[p..q] A[q+1..r]};
    
    \item \hypertarget{mergesort}{\textbf{\textsc{mergeSort\_weight(array, p, r)}}}: metodo che implementa l'algortimo di ordinamento mergeSort;
    
    \item \hypertarget{dfsciclo}{\textbf{\textsc{dfs\_ciclo(g, u, padri, visitati)}}}: metodo utilizzato per la ricerca di cicli nell'algoritmo \hyperlink{section.4}{\textsc{Kruskal-naive}}. La funzione prende in input un grafo da analizzare, un nodo di partenza, un vettore dei padri e un vettore dei visitati (inizializzati a 0). Viene eseguita una visita DFS de grafo e ad ogni iterazione viene visitato un nodo e ricorsivamente tutti i suoi vicini impostando ad 1 il vettore dei visitati e costruendo il vettore dei padri, se si incontra un nodo già visitato (ad eccezione del padre) la funzione restituisce True, poichè è stato trovato un ciclo nel grafo;
    
    \item \hypertarget{dfssupporto}{\textbf{\textsc{dfs\_supporto(g, u, n\_nodi, visitati)}}}: metodo utilizzato per testare la correttezza dei risultati ottenuti, si rimanda alla  \hyperlink{section.6}{Sezione Correttezza};
    
    \item \hypertarget{testalberosupporto}{\textbf{\textsc{test\_albero\_supporto(lista\_grafi)}}}: metodo utilizzato per testare la correttezza, si rimanda alla \hyperlink{section.6}{Sezione Correttezza};
    
    \item \textbf{\textsc{output\_peso(prim, kruskal, kruskal\_naive, lista\_grafi\_originale, p\_t, k\_t, kn\_t)}}: metodo utilizzato per stamprare a schermo tutti i risultati ottenuti, sulla base dell'outuput di questo metodo sono state composte le tabelle nella \hyperlink{section.8}{Sezione Conclusioni}.
    
\end{itemize} 

Seguono i metodi utilizzati per implementare \textsc{Kruskal-UnionFind}:
\begin{itemize}
    \item \hypertarget{makeset}{\textbf{\textsc{MakeSet(nodo)}}}: metodo che prende in input un nodo e lo inizializza come padre di sé stesso;
    
    \item \hypertarget{union}{\textbf{\textsc{Union(nodo1, nodo2, g)}}}: metodo che prende in input due nodi e un grafo e, se questi due nodi fanno parte di due insiemi disguinti diversi, unisce le componenti connesse che li contengono, facendo puntare la radice dell'albero con profondità minima a quella del secondo albero, minimizzando quindi la profondità totale;
    
    \item \hypertarget{findset}{\textbf{\textsc{FindSet(g, nodo1)}}}: metodo che ritorna la radice dell'insieme in cui è contenuto il nodo1 passato in input, risalendo di padre in padre fino a trovare un self-loop (ossia un elemento che punta a sé stesso).
\end{itemize}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Heap}
\label{Heap}

L'oggetto \textit{Heap} contiene le funzioni che permettono di realizzare un \textit{min-heap}. Uno heap è una struttura dati che si può considerare un albero binario quasi completo, ovvero un albero nel quale tutti i livelli sono riempiti quasi completamente tranne l'ultimo. Le caratteristiche dello heap sono:

\begin{itemize}
    \item l'ultimo livello incompleto si riempie da sinistra;
    \item l'albero viene rappresentato sotto forma di array A che è caratterizzato da \textit{A.length} che rappresenta la lunghezza di A e \textit{A.heapsize} che rappresenta la dimensione dello heap.
\end{itemize}


Per implementare l'algoritmo è stato realizzato un \textit{min-heap}, uno heap caratterizzato da nodi con la chiave minore o uguale a quella dei figli. Quindi la radice rappresenta l'elemento più piccolo del \textit{min-heap}.


\begin{itemize}
    \item \textbf{vector}: vettore associato allo heap;
    \item \textbf{length}: lunghezza del vettore;
    \item \textbf{heapsize}: lunghezza dello heap;
    \item \hypertarget{buildminheap}{\textbf{\textsc{BuildMinHeap(h)}}}: metodo che dato in input l'oggetto heap, costruisce un \textit{min-heap};
    \item \hypertarget{minheapify}{\textbf{\textsc{MinHeapify(h, i)}}}: metodo che dato in input un vettore e un nodo, sistema il nodo nella posizione corretta;
    \item \hypertarget{heapdecreasekey}{\textbf{\textsc{HeapDecreaseKey(h, i ,key)}}}: metodo che dato in input uno heap, un indice ed una nuova chiave, sostituisce il valore del vettore associato all'indice i con il nuovo valore key;
    \item \hypertarget{heapminimum}{\textbf{\textsc{HeapMinimum(h)}}}: metodo che dato in input uno heap, restituisce il valore minimo dello heap, ossia la radice;
    \item \hypertarget{heapextractmin}{\textbf{\textsc{HeapExtractMin(h)}}}: metodo che dato in input uno heap, trova l'elemento più piccolo, lo rimuove e ritorna l'oggetto;
    \item \hypertarget{isin}{\textbf{\textsc{isIn(h, v)}}}: metodo che, dato in input un nodo, restituisce 1 se esso è presente nello heap, 0 altrimenti. Per rendere questa operazione di tempo costante è stata aggiunto un attributo \hyperlink{inh}{\textit{in\_h}} ad ogni nodo;
    \item \hypertarget{right}{\textbf{\textsc{right(index)}}}: metodo che, dato in input un indice di un nodo, restituisce l'indice del nodo figlio destro;
    \item \hypertarget{left}{\textbf{\textsc{left(index)}}}: metodo che, dato in input un indice di un nodo, restituisce l'indice del nodo figlio sinistro;
    \item \hypertarget{parent}{\textbf{\textsc{parent(index)}}}:metodo che, dato in input un indice di un nodo, restituisce l'indice del padre.
\end{itemize}


\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Main}
\label{Main}

La classe \textit{Main} contiene il dataset dei grafi dopo l'esecuzione del parsing, le funzioni di parsing, di misurazione di performance e le implementazioni degli algoritmi:

\begin{itemize}
    
    \item \textbf{lista\_grafi}: vettore utilizzato per la memorizzazione dei grafi dopo l'esecuzione del \hyperlink{parsing}{parsing};
    
    \item \textbf{p\_g}: vettore contenente i grafi risultanti dall'esecuzione dell'algoritmo \texttt{Prim};
    
    \item \textbf{k\_g}: vettore contenente i grafi risultanti dall'esecuzione dell'algoritmo \texttt{Kruskal-UnionFind};
    
    \item \textbf{kn\_g}: vettore contenente i grafi risultanti dall'esecuzione dell'algoritmo \texttt{Kruskal-Naive};
    
    \item \textbf{p\_t}: vettore contenente i tempi necessari per l'esecuzione dell'algoritmo \texttt{Prim};
    
    \item \textbf{k\_t}: vettore contenente i tempi necessari per l'esecuzione dell'algoritmo \texttt{Kruskal-UnionFind};
    
    \item \textbf{kn\_t}: vettore contenente i tempi necessari per l'esecuzione dell'algoritmo \texttt{Kruskal-Naive};

    \item \hypertarget{parsing}{\textbf{\textsc{parsing(directory)}}}: funzione che, data in input una directory, analizza tutti i file interni e seleziona solo quelli con estensione .txt, fornendoli in input alla funzione \hyperlink{creagrafi}{crea\_grafi()};
    
    \item \hypertarget{creagrafi}{\textbf{\textsc{crea\_grafi(file)}}}: funzione che, dato in input un file, lo legge ed estrae le informazioni per la creazione di oggetti Grafo, Nodo e Arco;
    
    \item \hypertarget{plotgrafi}{\textbf{\textsc{plot\_graph()}}}: plot\_graph è una funzione che viene utilizzata per creare i grafici delle performance degli algoritmi utilizzati;
    
    \item \hypertarget{measureperformance}{\textbf{\textsc{measurePerformance()}}}:measurePerformance() è la funzione che viene utilizzata per calcolare tutte quelle metriche utili per valutare le performance di un algoritmo e per creare il successivo grafico. Le metriche calcolate sono:
   
    \begin{itemize}
        
        \item  \textbf{totTimes}: totTimes è una matrice avente di dimensionalità $mxn$ dove m è uguale al numero di algoritmi testati mentre n è il numero di dimensionalità di grafi considerati;
        
        \item\textbf{totRatios}: totRatios è una matrice della stessa dimensionlità di totTimes contenente tutti i ratio tra il tempo di calcolo medio tra le istanze di dimensionalità $n$ e il tempo di calcolo medio tra le istante di dimensionalità $m$ tale che $m>n$;
        
        \item  \textbf{totConstant}: totConstant è una matrice contenente le costanti nascoste per ogni algoritmo e per ogni dimensionalità di input considerata.
    \end{itemize}
    
    \item \hypertarget{measureruntime}{\textbf{\textsc{measure\_run\_time(n\_instances, graphs, algorithm)}}}: measure\_run\_time è la funzione chiamata da  measurePerformance() per calcolare i tempi di esecuzione di ciascun algoritmo. Per aumentare l'affidabilità delle misurazioni per istanze di bassa dimensionalità (numero di nodi <= 100) gli algoritmi sono stati ripetuti più volte (30) e poi il tempo è stato calcolato dividendo il tempo totale per questo numero di iterazioni. Per ottenere un ulteriore grado di accuratezza sulle misurazioni sono state testati 4 input della stessa dimensionalità $n$ per ogni $n$ e anche qui poi è stata presa la media.
\end{itemize}


\newpage