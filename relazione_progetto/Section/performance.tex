\section{Performance}
Abbiamo misurato le performance dei tre algoritmi utilizzando 68 grafi di diverse dimensioni.
I grafi testati hanno un numero di nodi che variavano dai  10 ai 100000.
Come già detto, per ogni dimensione sono presenti quattro grafi, per ottenere una misurazione più precisa in fase di misurazione, specialmente per i grafi con una dimensionalità minore.
\subsection{Prim}
L'algoritmo di Prim ha una complessità teoria di $O(mlogn)$, perciò ci aspettiamo indicativamente lo stesso risultato anche nella sua applicazione.

<grafico prim>
<grafico prim senza costante>
\subsection{Kruskal naive}
Per quanto riguarda la versione non ottimizzata dell'algoritmo di Kruskal, cioè quella che ad ogni iterazione del ciclo esegue una ricerca in profondità per assicurarsi che il nuovo arco non vada a creare cicli, ha una complessità di $O(mn)$.
<grafico kruskal naive>

Per la versione naive di Kruskal è stata fatta una piccola miglioria. L' algoritmo termina se:
\begin{itemize}
    \item ha scorso tutti i lati del grafo;
    \item ha aggiunto al grafo di copertura minimo n-1 archi, in questo caso termina l'esecuzione.
\end{itemize}
Dato che la maggior parte dei grafi testati mediamente aveva un numero maggiore di archi rispetto al numero di nodi, grazie alla seconda condizione la costante nascosta all'interno dell'algoritmo si è abbassata. 

\subsection{Kruskal}
Anche per kruskal, come Prim, ha una complessità di $O(mlogn)$

<grafico kruskal>
<grafico kruskal senza costante>

Come si nota dal grafico Kruskal è mediamente più veloce di Prim (in quanto ha una costante minore), anche se asintoticamente, sono equivalenti.

