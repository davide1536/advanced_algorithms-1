\section{Algoritmo di Prim}
\label{Prim}

L'algoritmo di Prim, dato un grafo G = (V,E) ed un nodo di partenza s, costruisce un MST, partendo da un albero A (con un singolo nodo) e aggiungendo, ad ogni passo, un light edge a lui collegato che sia sicuro\footnote{Un lato si dice sicuro se, la sua aggiunta, conserva l'invariante per cui: prima di ogni iterazione, A è un sottoinsieme di qualche albero di connessione minimo.} per A.

\subsection{Strutture dati}
\label{strutture_dati}

Le strutture dati utilizzate per implementare questo algoritmo sono:

\begin{itemize}
    \item classe Grafo;
    \item classe Nodo;
    \item classe Heap:
    \begin{itemize}
        \item metodo BuildMinHeap(h);
        \item metodo isIn(v);
        \item metodo HeapDecreaseKey(h, i, key).
    \end{itemize}
\end{itemize}

La descrizione si piò trovare alla sezione \textsc{1.2 Classi}.

\subsection{Implementazione}
\label{implementazione}

Questo algoritmo è stato implementato nel seguente modo:

\begin{itemize}
    \item è stata inizializzata la lista di nodi;
    \item al campo key di ogni nodo è stato assegnato il valore infinito;
    \item al campo key del nodo radice, dato in input, è stato assegnato il valore 0;
    \item è stata inizializzata una struttura heap a cui è stato passato come paramentro la lista dei nodi del grafo \texttt{g} dato in input;
    \item utilizzando il metodo \hyperlink{buildminheap}{\textsc{BuildMinHeap()}} è stato realizzato un min-heap;
    \item viene iterato lo heap e, grazie al metodo \hyperlink{heapextractmin}{\textsc{HeapExtractMin()}} , viene estratto il nodo con campo key minimo;
    \item viene salvato il suo valore key in modo da salvare il peso totale dell'albero una volta terminato l'algoritmo;
    \item per ogni arco nella lista di adiacenza del nodo estratto  viene controllato se il nodo adiacente è nell heap e se il peso dell'arco tra i due è minore del valore del campo key del nodo considerato. Se il risultato è positivo si procede con l'aggiornamento dei campi, utilizzando \hyperlink{heapdecreasekey}{\textsc{HeapDecreaseKey()}}.

Dato che \textsc{HeapDecreaseKey()} richiede in input la posizione del nodo che si vuole aggiornare, la prima implementazione è stata utilizzando la funzione python index() ma, andando ad analizzare successivamente la complessità di Prim essa non corrispondeva alla complessità teorica di $O(m log{} n)$. Quindi è stato aggiundo un ulteriore campo \textsc{heapIndex} alla classe node per tenere traccia degli indici dei nodi all'interno dell heap e riducendo così la complessità di recucpero dell'indice da $O(n)$ a $O(1)$.

\end{itemize}
